# Usecode Conversion Project

## Meta

All `*.uc`, `*.ucxt`, and `*.uca` files are different forms of usecode — scripting languages meant to be transformed into Usecode bytecode to be used in the game engines of:

* Ultima VII: The Black Gate ("BG")
* Ultima VII: The Forge of Virtue ("FOV")
* Ultima VII Part 2: The Serpent Isle Beta ("SIB")
* Ultima VII Part 2: The Serpent Isle ("SI")
* Ultima VII Part 2: The Silver Seed ("SS")
* Exult (an open-source, clean-room reverse engineered recreation of those engines for modern computers and operating systems)

Some of these games had official translations:

* BG was translated into German ("BGDE"), Spanish ("BGES"), and French ("BGFR")
* SI was translated into Spanish ("SIES")

## Tools

* `ucc`: The Usecode C Compiler, a compiler created by `Exult` team. This will compile input files into Usecode bytecode. `ucc` can generate `Exult`-specific opcodes that don't work on the original games — but there is a subset of Usecode C that will generated bytecode can be used directly in the original games.

* `wuc`: Wody's UseCode assembler, a compiler originally written by Wody and donated to `Exult` team, which now maintains it. It uses a custom assembly language that maps directly into usecode bytecode. It accepts mnemonics of `Exult`-specific opcodes.

* `ucxt`: UseCode eXtractor Tool, a disassembler/decompiler that can extract the usecode of the original games into low-level formats that can be fed into either `ucc`, or `wuc`, depending on flags.

**⚠️ Version Requirement**: Only the newest versions are guaranteed to work. The tools are continuously updated with new features to reproduce original usecode as faithfully as possible. If builds fail, ensure you have the latest versions of `ucc`, `ucxt`, and `wuc` from the Exult project. Older versions may lack syntax changes/code generation needed for accurate compilation/decompilation.

## File Formats

* `*.uc`: These are Usecode C files, a high-level C++-inspired scripting language created by the `Exult` team and designed to be compiled into usecode byte-code with `ucc`. These files are meant to be written by humans, and has friendlier control flow structures and abstractions.

* `*.ucxt`: These are Usecode C files extracted by `ucxt`. This is a proper-subset of Usecode C which is output by `ucxt`, and typically closely matches the input usecode bytecode. It is generally not meant to be written by people — instead, people will start with a `*.ucxt` file and massage it into an `*.uc` file, using the fact that `ucc` accepts `ucxt` output.

* `*.uca`: These are Usecode Assembly files, an assembly language created by the `Exult` team and designed to be assembled into usecode byte-code with `wuc`.

## Usecode Syntax and Intrinsics

The syntax for this language is documented in [EBNF notation](usecode-syntax.ebnf) (EBNF) and [usecode-syntax.yy](usecode-syntax.yy) (simplified Bison).

Usecode Intrinsics are functions exported by the game engine to the scripting engine. Their name typically starts with "UI_" (for "Usecode Intrinsic). They can also be called in object notation without the preceding "UI_": for example, the following two lines are identical:

```ucc
UI_in_usecode(obj)
obj->in_usecode()
```

There is comprehensive documentation on intrinsics in [exult_intrinsics.txt](exult_intrinsics.txt).

## Project Structure

* `uca/` directory: contains Usecode assembly files extracted from the original games, for comparative analysis. In particular, the SIES game had debug opcodes in the final Usecode bytecode, and so this one is dumped as assembly to be inspected.
* `ucxt/` directory: contains Usecode C files extracted from the original games, for comparative analysis.
* `fov/` and `ss/` directories: contain an in-progress manual conversion of `usecode.fov.ucxt` and `usecode.ss.ucxt` to a higher-level version suitable for people to use.
  * `fov/data.md`: documents all engine-called Usecode functions for Forge of Virtue, including hard-coded functions, weapon hit callbacks, and Usecode egg placements organized by map chunk.
  * `ss/data.md`: documents all engine-called Usecode functions for Silver Seed, including hard-coded functions, weapon hit callbacks, and Usecode egg placements organized by map chunk.

## Testing and Building

To use this repository effectively, you need:

* A UNIX-compatible environment: Linux, Mac OSX, and BSD are natively supported. On Windows, use WSL2, msys2, or cygwin (enabling real symlinks is recommended for the latter two).
* GNU make: available as `make` on Linux and as `gmake` on BSD and Mac OSX.
* The Exult tools: specifically `ucc` and `ucxt`, installed and available in your PATH.
* A syntax-aware editor: VSCode with the [Exult Usecode Syntax](https://marketplace.visualstudio.com/items?itemName=Exult.usecode-syntax) extension is recommended.

The main files can be built with `make fov` or `make ss`. They can be checked with `make check.fov` or `make check.ss`. Doing a plain `make` or `make all` will build and check both `fov` and `ss`, while a `make check` is equivalent to doing `make check.fov check.ss`.

A `make ref` can be used to build the reference files used by `check.fov` and `check.ss`, but this should probably never be used.

### Build Process Details

Due to the fact that `ucc` does a few optimizations when compiling usecode, the high-level file needs to be compiled without symbols, extracted with `ucxt`, the extracted output must be recompiled with `ucc`, and the output of this is extracted with `ucxt`. This is done when generating the reference files in `make ref`, as well as when doing `make fov` or `make ss`.

For agent-oriented build information and task-specific guidance, see [AGENTS.md](AGENTS.md).

## Project goal and fidelity checks

The primary purpose of this repository is to maintain a high-level Usecode C version that executes as faithfully as possible to the original games. The `check` target is structured to surface fidelity regressions introduced by `ucc` optimizations (dead-code elimination, jump retargeting, etc.), as well as to catch mistakes done when refactoring or converting the code to higher-level Usecode C. Each check rebuilds both sides for comparison:

* "Original usecode" → `ucxt` → `ucc` → `ucxt`
* "High-level usecode" → `ucc` → `ucxt`

Dead code present in the original was painstakingly restored by diffing `ucxt` emitted directly from the originals against `ucxt` emitted after recompiling originals with `ucc`, and manually decompiled.

The basic workflow was as follows:

1. Patched original usecode bytecode to fix a few bad external function references that caused `ucxt` to mis-decompile some functions.
2. Ran the patched bytecode through `ucxt`, and then fed its output through an old VB6 "prettifier" for `ucxt` output. I wrote this tool ages ago, and it has its bugs — like dropped blocks due to nontrivial control flow in the original games — but it gives a workable starting point. I used this output as a basis for a lot of things I did in Keyring and SI Fixes.
3. Extended `ucc` so it can directly compile `ucxt` output.
4. Iterated (effectively `make all` each time): copy missing lines from raw `ucxt` when the prettifier lost them; hand-prettify; add higher-level control-flow/features to `ucc` and update the prettified sources to use them; repeat until generated output matched originals and was largely free of bare `goto`/`attend`. When there were no more issues stemming from the VB6 prettifier, I moved on to 5:
5. Iterated on documentation and naming: added constants, function names, and comments, always making sure to `make all` to check for mismatches.

The usecode contains annotation comments using the following conventions:

* `BUG:` identifies bugs in the original usecode.
* `TYPO:` identifies misspellings (archaic word forms are considered valid, so modern spellcheckers may disagree).
* `TODO:` marks planned improvements to `ucc` that would simplify the decompiled usecode.
* `NOTE:` provides additional context, primarily documenting restored dead code.

## Engine-Called Functions Reference

The [fov/data.md](fov/data.md) and [ss/data.md](ss/data.md) files document all Usecode functions invoked directly by the game engine (not called by other Usecode):

* **Shape functions** (`shape#<N>`): triggered when shape `<N>` is double-clicked or runs events.
* **NPC functions** (`object#(0x400 - <M>)`): the first 256 NPCs call `function = NPC_ID + 0x400` on interaction or schedule events.
* **Hard-coded functions**: engine callbacks for avatar death, speech/voice eggs, sleep/sit schedules, arresting guards, object destruction, copy-protection failure, etc.
* **Weapon hit callbacks**: functions defined in `WEAPONS.DAT` called when specific weapons hit targets (e.g., Ignite, Dispel Magic, Death Bolt, Telekinesis).
* **Usecode egg dump**: complete listing of all placed Usecode eggs organized by map chunk, with world coordinates `[x, y, z]` (tile positions from map origin + height), function numbers, and Quality values. Eggs with function `0x000` are disabled (likely cut content). Some chunks have duplicate entries representing multiple eggs at the same coordinates.

## Outstanding issues

Usecode has embedded scripts (which I will call "scripts", for short). `ucc` has a higher level version of those (the `script` block), which compile down to either `UI_execute_usecode_array` or `UI_delayed_execute_usecode_array` intrinsics.

There is an issue that stems from the buggy way that the original games handle embedded values in scripts which currently neither `ucc` nor `Exult` handle in the same way as the original. And this leads to puzzling things when decompiling the original games, as well as an observable behavior difference in the compiled Usecode scripts.

In detail:

When `ucc` writes values to a script, it writes them as "usecode values" into an array. The `repeat` embedded script opcode needs to know where to jump to if it will loop; and `ucc` counts the number of elements in the array to jump back by. When executing these embedded scripts, `Exult` reads the values as "usecode values", and uses the array of "usecode values" to run scripts.

But the original games did this differently: when the script's "usecode values" are read, they are *serialized* into a byte array. The execution engine will then read the bytecode for the script from this array and execute it.

And here is the issue: when serializing a value, what the originals did was:

* if it is a string, it is written as `"` (string bytes) `"` (so no embedded `"` are allowed in strings).
* otherwise it is an integer:
  * if the (signed 16-bit) value of the integer is `> 255`, write it as two (little-endian) bytes
  * otherwise, it is written as a single byte.

This has the effects of:

* the values written lose information of the size they had, and can be one or two bytes
* any negative values will lose their top byte

And this has huge consequences:

* if the script opcode expects a 1-byte parameter at that position:
  * positive or negative values that can be sign-extended from 8- to 16-bits without loss will be fine
  * negative values that require 2-bytes will lose their top byte and change value, which can range in effect from minor (does the wrong thing for this opcode, but otherwise executes as expected) to major (may change control flow, e.g., a `repeat` target)
  * positive values that require 2-bytes will cause the script to  *either* incorrectly fetch the top byte as another argument, *or* cause the script to execute the top byte as the next opcode
* if the script opcode expects a 2-byte parameter at that position:
  * positive values that require 2-bytes are fine
  * positive values that require only 1-byte need to be padded with a `0` value or they will cause whatever comes next to be interpreted as the top byte
  * negative values must be written as 2 bytes or they will lose their top byte

So in order to work on the original games, here is what `ucc` "should" do:

1. Places where values are required to be 16-bits:
    * if value comes from a variable, write code to evaluate and add to the array the (low byte first, then high byte; i.e., little-endian) pair of values `(uint16_t)variable % 256` and `(uint16_t)variable / 256`
    * if a statically known value is positive and `< 256`, it needs to be followed by a `0` padding value
    * if a statically known value is positive and `> 256`, it must not have a padding value after
    * if a statically known value is negative, it must always be written as `(uint16_t)value % 256` and `(uint16_t)value / 256`
2. Places where values are required to be 8-bits
    * if value comes from a variable, write code to evaluate and add to the array the single value `(uint16_t)variable % 256`
    * if a statically known value fits in one byte, write it as-is
    * if a statically known value doesn't fit in one byte, generate an error

(1) is relevant for the `call` opcode, which expects a 16-bit function ID. The originals would just write the variable value, followed by a `0x00` in this case, as they never have usecode functions with IDs past `0x9ff` anyway.

(2) is relevant for every other opcode that has parameters, as they only take a single byte per parameter.

However, doing this would:

1. require changes in `Exult` to emulate the behavior of the originals in terms of reading values from the array (a large change)
2. it would still not solve the issue of broken usecode scripts in SS that jump *inside* "usecode values", as in this extract from SS:

    ```ucc
    var0005 = UI_execute_usecode_array(var0003, [0x0609, (byte)0x0B, -1, 6]);
    ```

    In `Exult`, the `0x0609` is a single value, is interpreted as an invalid opcode and treated as a `nop`. In the original games, the `0x0609` becomes two bytes, `0x09` and `0x06` (in this order due to endianness), both of which are invalid opcodes and treated as `nop`s.

    This makes both engines treat the `0x0B` as a `repeat` opcode with parameters `-1` (how many "elements" to jump back by), and `6` (number of repetitions). The jump offset is relative to the start of the opcode, meaning that the `repeat` will jump to the `0x06` byte in the original games, but to the `0x0609` value in `Exult`.

3. it would make the usecode in this repository strictly not equivalent to what was in the original games, defeating the documentation purposes of this repository

Perhaps a "hard-compatibility" mode of UCC should perform those actions, as well as disabling most Exult extensions, if one wants to use the generated usecode in the original games.
